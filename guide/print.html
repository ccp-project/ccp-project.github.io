<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CCP Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="intro.html">Introduction</a></li><li><a href="setup/index.html"><strong aria-hidden="true">1.</strong> Setup</a></li><li><a href="ccp_concepts/index.html"><strong aria-hidden="true">2.</strong> CCP Programming Model</a></li><li><a href="documentation/index.html"><strong aria-hidden="true">3.</strong> API Documentation</a></li><li><ol class="section"><li><a href="documentation/datapath.html"><strong aria-hidden="true">3.1.</strong> Datapath Program Syntax</a></li><li><a href="documentation/rust/index.html"><strong aria-hidden="true">3.2.</strong> Rust</a></li><li><a href="documentation/python/index.html"><strong aria-hidden="true">3.3.</strong> Python</a></li></ol></li><li><a href="tutorial/index.html"><strong aria-hidden="true">4.</strong> Tutorial</a></li><li><ol class="section"><li><a href="tutorial/implementation.html"><strong aria-hidden="true">4.1.</strong> Structure</a></li><li><a href="tutorial/init.html"><strong aria-hidden="true">4.2.</strong> Writing init_programs</a></li><li><a href="tutorial/create.html"><strong aria-hidden="true">4.3.</strong> Writing create</a></li><li><a href="tutorial/report.html"><strong aria-hidden="true">4.4.</strong> Writing on_report</a></li><li><a href="tutorial/source.html"><strong aria-hidden="true">4.5.</strong> Full Example</a></li></ol></li><li><a href="running.html"><strong aria-hidden="true">5.</strong> Running CCP Algorithms</a></li><li><a href="emulation.html"><strong aria-hidden="true">6.</strong> Emulating and Debugging</a></li><li><a href="problems/index.html"><strong aria-hidden="true">7.</strong> Common Problems</a></li><li><a href="libccp/index.html"><strong aria-hidden="true">8.</strong> Adding Datapath Support</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">CCP Guide</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p>The congestion control plane (CCP) is a new platform for writing and sharing datapath-agnostic congestion control algorithms.
It makes it easy to to program sophisticated algorithms (write Rust or Python in a safe user-space environment
as opposed to writing C and a risk of crashing your kernel), and allows the same algorithm
implementation to be run on a variety of datapaths (Linux Kernel, DPDK or QUIC).</p>
<p>You probably ended up at this guide for one of three reasons. You want to...</p>
<ol>
<li><strong>Run an existing algorithm</strong> -- If you just want to use a CCP algorithm that's already been implemented (either by us or someone else),
use the <a href="./setup/index.html">following section</a> to install the necessary dependencies, then skip to
<a href="./running.html">Section 5</a> for instructions on building and running algorithms.</li>
<li><strong>Build a new algorithm</strong> -- If you want to write your own algorithm using CCP, you should follow the rest of the guide in order.
If you just want to do something simple, it may be sufficient to copy one of our existing algorithm
repositories and modify it to fit your needs, but at the very least you will want to follow
the instructions in the <a href="./setup/index.html">setup</a> section below.</li>
<li><strong>Reproduce Results</strong> -- If you'd like to reproduce the results found in our SIGCOMM '18 paper, please see the
<a href="https://github.com/ccp-project/eval-scripts">eval-scripts</a> repository.</li>
</ol>
<p><strong>NOTE</strong>: Portus is our Rust implementation of CCP, but in most cases you <em>won't actually need to
clone or build it</em> individually because it is provided as a library. Whether you are writing your
own algorithm or using an existing one, Portus is available through package managers in Rust (cargo)
and Python (pip). You only need to check out the repository directly if you would like to make changes
to the library/API itself.</p>
<a class="header" href="#setup" id="setup"><h1>Setup</h1></a>
<ol>
<li>
<p>Regardless of whether you'd like to run or build an algorithm in Rust or Python, you'll need to install Rust (nightly version) and Cargo (Rust's package manager). Any method of installing Rust should work, but we recommend the following:</p>
<pre><code> curl https://sh.rustup.rs -sSf | sh -- -y -v --default-toolchain nightly
</code></pre>
</li>
<li>
<p>Next, you'll need to pick a datapath and install our datapath integration. We currently support the following three datapaths. If you're not sure, you probably want the Linux Kernel. This integration has received the most use and is the easiest to set up, but we have successfully run all of the same experiments and tests on the other datapaths as well. If you would like to use a datapath that is not listed below, you'll need to add support yourself (see <a href="../libccp/index.html">New Datapaths</a>).</p>
<p><details><summary><b>Linux (kernel module)</b></summary><p></p>
<p>Clone our kernel module:</p>
<p><code>git clone https://github.com/ccp-project/ccp-kernel.git</code></p>
<p>Fetch submodules:</p>
<p><code>git submodule update --init --recursive</code></p>
<p>Build:</p>
<p><code>cd ccp-kernel &amp;&amp; make</code></p>
<p>Install: (provide <code>ipc=0</code> to use netlink sockets):</p>
<p><code>sudo ./ccp_kernel_load ipc=0</code></p>
 </p></details>
<p><details><summary><b>mTCP / DPDK (fork)</b></summary><p></p>
<p>Clone our fork:</p>
<p><code>git clone https://github.com/ccp-project/ccp-mtcp.git</code></p>
<p>Follow the instructions in <code>REAMDE.md</code> for building mTCP as normal (and for building DPDK first, if you haven't done so already).</p>
<p>More detailed instructions coming soon.</p>
 </p></details>
<p><details><summary><b>Google QUIC (patch)</b></summary><p></p>
<p>Our patch currently lives at <a href="https://github.com/ccp-project/ccp-quic">https://github.com/ccp-project/ccp-quic</a></p>
<p>Follow the instructions in <code>README.md</code> for applying the patch.</p>
<p>More specific instructions for getting QUIC setup from scratch coming soon.</p>
 </p></details>
 <br />
</li>
<li>
<p>Clone an existing algorithm or write your own by following the rest of the guide. We have implemented the following algorithms:</p>
<ul>
<li><a href="https://github.com/ccp-project/bbr">BBR</a></li>
<li><a href="https://github.com/venkatarun95/ccp_copa">Copa</a></li>
<li><a href="https://github.com/ccp-project/nimbus">Nimbus</a></li>
<li><a href="https://github.com/ccp-project/generic-cong-avoid">Reno and Cubic</a></li>
</ul>
</li>
<li>
<p>Build the algorithm</p>
<p><details><summary><b>Rust</b></summary><p></p>
<p>Just run <code>cargo build</code> in the root of the repository. If you run into any build errors, see <a href="./problems/index.html">Common Problems</a>.</p>
 </p></details>
 <details><summary><b>Python</b></summary><p>
<p>Assuming you have python and pip installed, just run <code>pip install --user portus</code>. If you run into any build errors, see <a href="./problems/index.html">Common Problems</a>.</p>
 </p></details>
</li>
<li>
<p>Follow instructions in <a href="../running.html">Running Algorithms</a> to use CCP.</p>
</li>
</ol>
<a class="header" href="#ccp-programming-model" id="ccp-programming-model"><h1>CCP Programming Model</h1></a>
<p>Traditionally, congestion control algorithms, and thus the API provided by datapaths, have been designed around the idea of taking some action upon receiving each packet acknowledgement.</p>
<p>In contrast, CCP is built around the idea of moving the core congestion control logic off of the immediate datapath in order to gain programmability. However, in order to maintain good performance, rather than moving it entirely, we split the implementation of a congestion control algorithm between the datapath and a userspace agent. The datapath component is restricted to a simple LISP-like language and is primarily used for collecting statistics and dictating sending behavior, while the userspace algorithm can be arbitrarily complex and is written in a language like Rust or Python with the support of all their available libraries.</p>
<p>Thus, writing an algorithm in CCP actually involves writing two programs that work in tandem and communicate asynchronously, which requires a slightly different way of thinking about congestion control implementation. Typically, the datapath program will look at each ACK to gather statistics and periodically report a summary of those statistics to the userspace agent, who then makes a decision about how to modify the sending behavior. In other words, the userspace agent is typically making a decision based on a batch of ACKs rather than each individual one. We initially experimented with reporting every single ACK to the userspace agent, but we found that (1) this doesn't scale sufficiently, and (2) responding on a less-frequent basis, e.g. once-per-RTT, does not compromise performance of any algorithms we tested.</p>
<p>More details and experimental results can be found in our <a href="https://people.csail.mit.edu/frankc/pubs/ccp-sigcomm18.pdf">SIGCOMM '18 paper</a>.</p>
<p>The syntax and structure of the datapath program language is detailed in the <a href="../documentation/datapath.html">following section</a>.</p>
<a class="header" href="#documentation" id="documentation"><h1>Documentation</h1></a>
<p>CCP currently supports writing algorithms in Rust, or (through language bindings) Python.
We don't plan on adding new language bindings in the near future, but will gladly accept pull requests!</p>
<p>Whichever language you decide to use, you will also need to understand our domain-specific language
for writing datapath programs (don't worry, it's very simple!).
See the following section for the syntax and capabilities of this
language.</p>
<a class="header" href="#datapath-programs" id="datapath-programs"><h1>Datapath Programs</h1></a>
<p>CCP datapath programs use a LISP-like syntax (parenthesized, prefix notation), but have a very limited set of functionality: the language is expressive enough to accomplish anything you might need for congestion control, but limited enough that the programs are very easy to reason about. The language is intentionally not turing complete for security purposes.</p>
<p>Datapath programs are <a href="https://en.wikipedia.org/wiki/Event-driven_programming">event-driven</a> programs that run in the context of each individual flow.</p>
<p>The required structure of these programs is simple: a single block of variable definitions, followed by a series of events and corresponding event handlers.</p>
<a class="header" href="#variable-definitions" id="variable-definitions"><h2>Variable Definitions</h2></a>
<p>Variables only have two possible types: booleans and integers (which are internally represented as <code>u64</code>), and must be given a default value.</p>
<p>There are two classes of variables:</p>
<ul>
<li><em>Report</em> variables are included in all reports sent to the userspace agent each time the <code>(report)</code> command is called (more on this below).</li>
<li><em>Control</em> variables are not included in reports.</li>
</ul>
<p>Adding the keyword <code>volatile</code> before a variable name means that it will automatically be reset to its provided default value when the <code>(report)</code> command is called. Both report variables and control variables may be volatile. Volatile control variables will still be reset to their default on each report, they just won't be included in the report.</p>
<p>The first expression in a datapath program <em>must</em> be the variable definition. The syntax is best explained by example:</p>
<pre><code class="language-c">(def
    (Report
        (volatile reportVarA 0)
        (reportBarB true)
        ...
    )
    (contolVarA true)
    (volatile controlVarB false)
    ...
)
</code></pre>
<p>In this example, we have two report variables and two control variables. The include &quot;report&quot; and &quot;control&quot; in the names for clarity, but this is not a requirement. When the <code>(report)</code> statement is reached, <code>reportVarA</code> and <code>controlVarB</code> will be reset to 0 and false, respectively, while <code>reportVarB</code> and <code>controlVarA</code> will not.</p>
<a class="header" href="#events-and-handlers" id="events-and-handlers"><h2>Events and Handlers</h2></a>
<p>Following the variable definition expression is a series of <code>when</code> clauses, each of which define a condition and a series of statements to be executed when that condition becomes true.</p>
<p>The syntax is <code>(when [condition] [statements])</code> where &quot;condition&quot; is any expression (all expressions evaluate to a true or false value, as in C), and &quot;statements&quot; is a series of expressions.</p>
<a class="header" href="#operations" id="operations"><h2>Operations</h2></a>
<ul>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
<li><code>:=</code> or <code>bind</code> for setting variables</li>
<li>Boolean operators (<code>||</code> and <code>&amp;&amp;</code>)</li>
<li><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code></li>
</ul>
<a class="header" href="#control-flow" id="control-flow"><h2>Control Flow</h2></a>
<ul>
<li><code>If</code> statements</li>
<li>No loops</li>
<li><code>(fallthrough)</code></li>
<li><code>(report)</code></li>
</ul>
<a class="header" href="#flow-and-ack-statistics" id="flow-and-ack-statistics"><h2>Flow and ACK Statistics</h2></a>
<p>The <code>Flow</code> struct provides read-only access to a number of a flow-level statistics that are maintained by the datapath:</p>
<ul>
<li><code>Flow.packets_in_flight</code></li>
<li><code>Flow.bytes_in_flight</code></li>
<li><code>Flow.bytes_pending</code>: bytes currently buffered in the network stack waiting to be sent</li>
<li><code>Flow.rtt_sample_us</code>: sample of the RTT in microseconds based on ACK arrivals for this flow</li>
<li><code>Flow.was_timeout</code>: boolean indicating whether or not this flow has received a timeout</li>
<li><code>Flow.rate_incoming</code>: estimate of the receive rate over the last RTT</li>
<li><code>Flow.rate_outgoing</code>: estimate of the send rate over the last RTT</li>
</ul>
<p>The <code>Ack</code> struct provides read-only access to specific information from the single most recently received ack.</p>
<ul>
<li><code>Ack.bytes_acked</code></li>
<li><code>Ack.packets_acked</code></li>
<li><code>Ack.bytes_misordered</code></li>
<li><code>Ack.packets_misordered</code></li>
<li><code>Ack.ecn_bytes</code></li>
<li><code>Ack.ecn_packets</code></li>
<li><code>Ack.lost_pkts_sample</code></li>
<li><code>Ack.now</code></li>
</ul>
<a class="header" href="#sending-behavior" id="sending-behavior"><h2>Sending Behavior</h2></a>
<p>The sending behavior of a flow can only be controlled by modifying either the <code>Cwnd</code> or <code>Rate</code> variables. These can be set either directly inside of a datapath program, or via an <code>update_fields</code> call in the userspace agent.</p>
<p>For example, to increase the cwnd by the number of bytes acked on each ack (i.e. slow-start):</p>
<pre><code class="language-c">(when true
    (:= Cwnd (+ Cwnd Ack.bytes_acked))
)
</code></pre>
<p>This is equivalent to <code>cwnd += Ack.bytes_acked</code>.</p>
<a class="header" href="#common-expressions" id="common-expressions"><h2>Common Expressions</h2></a>
<a class="header" href="#when-true" id="when-true"><h3>when true</h3></a>
<p>Expressions inside of a <code>when true</code> clause are run on every ack.</p>
<a class="header" href="#timers" id="timers"><h3>Timers</h3></a>
<p>Timers can be achieved using <code>Micros</code></p>
<a class="header" href="#rate-patterns" id="rate-patterns"><h3>Rate Patterns</h3></a>
<pre><code>(
)
</code></pre>
<a class="header" href="#rust" id="rust"><h1>Rust</h1></a>
<p>See <a href="http://docs.rs/portus">docs.rs/portus</a>.</p>
<a class="header" href="#python" id="python"><h1>Python</h1></a>
<p>Coming soon!</p>
<p>For now, following the Python version of the tutorial below should be sufficient.</p>
<p>Please reach out to us at ccp@csail.mit.edu if you have any problems.</p>
<a class="header" href="#tutorial" id="tutorial"><h1>Tutorial</h1></a>
<p>In this tutorial, we'll walk through the process of implementing a very simple congestion control algorithm in CCP and then running and debugging that implementation in an emulator.</p>
<p>We'll be using <strong>Portus v0.3.3</strong>. The first part covering algorithm implementation is agnostic to datapath, but for the second part we'll be using the <strong>Linux Kernel datapath</strong>. Please let us know if you run into any problems during this tutorial by submitting a GitHub issue.</p>
<p>The focus here is to explain the CCP programming model, so we'll be implementing a very simple scheme: AIMD (additive-increase multiplicative-decrease). Before we even start talking about CCP, let's briefly go over exactly how the algorithm works and what kind of behavior we expect to see. We assume a basic familiarity with the problem of congestion control. If you need some background, <a href="http://web.mit.edu/6.829/www/currentsemester/papers/vanjacobson-congavoid.pdf">Van Jacobson's paper</a> is a good place to start.</p>
<a class="header" href="#aimd-scheme" id="aimd-scheme"><h3>AIMD Scheme</h3></a>
<p>The high-level idea is to start with a low cwnd, and then as ACKs are received, probe for more bandwidth by continually increasing the cwnd (additively) until eventually a loss occurs, which signals congestion. We then cut our rate (multiplicatively) and repeat. If you were to graph the congestion window over time of a single flow running this scheme in the prescence of a droptail buffer, it would exhibit the classic &quot;sawtooth&quot; behavior:</p>
<p><img src="./sawtooth.jpg" alt="" /></p>
<p>Specifically, we'll use the following algorithm:</p>
<ul>
<li>On each ACK, increase CWND by 1/cwnd (this has the affect of increasing the cwnd by roughly 1 packet per RTT)</li>
<li>On each loss, cut CWND by 1/2</li>
</ul>
<a class="header" href="#implementation" id="implementation"><h1>Implementation</h1></a>
<p><details><summary><b>Python</b></summary></p>
<p>
In Portus, a congestion control algorithm is represented as a python class and a new instance of this class is created for each flow (and deleted when this flow ends). This class must be a subclass of `portus.AlgBase` and must implement the following 3 methods:
<ol>
<li><code>init_programs()</code>: return all DATAPATH programs that your algorithm will use.
<ul>
<li>Returns a list of 2-tuples, where each tuple consists of (1) a unique (string-literal) name for the program, and (2) the program itself (also a string-literal).</li>
<li><strong>Note</strong>: this is a static/class method, it does not take self, and thus will produce the same result for all flows</li>
</ul>
</li>
<li><code>on_create(self)</code>: initialize any per-flow state (and store it in <code>self</code>), and choose an initial datapath program to use.
<ul>
<li>Doesn't return anything.</li>
</ul>
</li>
<li><code>on_report(self, r)</code>: all algorithm logic goes here, called each time your datapath progarm executes <code>(report)</code>.
<ul>
<li>The report parameter <code>r</code> is a report containing all of the fields you defined in your datapath program Report structure, plus two permanent fields, <code>Cwnd</code> and <code>Rate</code>, which are the current congestion window and rate in the datapath at the time of this report.</li>
<li>Doesn't return anything.</li>
</ul>
</li>
</ol>
<p>Since python (2) doesn't have type annotations, we use our own runtime type checker to ensure:</p>
<ul>
<li>Your class is a subclass of <code>portus.AlgBase</code>.</li>
<li>All 3 methods are implemented.</li>
<li>Each method takes the correct parameters (names must match <em>exactly</em>).</li>
<li>Each method returns the correct type (mainly relevant for <code>init_programs</code>).</li>
</ul>
<p>Thus, the minimal working example that will pass our type checker is as follows:</p>
<pre><code class="language-python">import portus

class AIMD(portus.AlgBase):          # &lt;-- subclass of AlgBase

    def init_programs(self):
        return [(&quot;name&quot;, &quot;program&quot;)] # &lt;-- note the example return type

    def on_create(self):
        # TODO initial state
        # TODO self.datapath.set_program(...)
        pass

    def on_report(self, r):
        # TODO do stuff with r
        # TODO maybe change cwnd or rate: self.datapath.update_field(...)
        pass
</code></pre>
<p>Starting with this base, we will go through the implementation of AIMD one function at a time...</p>
</p>
</details>
<p><details><summary>Rust</summary></p>
<p>
    Some rust stuff here...
</p>
</details>
<a class="header" href="#init_programsself" id="init_programsself"><h1>init_programs(self)</h1></a>
<p>To start out, we need to think about how to split the implemention between the datapath and userspace. For AIMD, the main things we need to keep track of are ACKs to increment our window and losses to cut our window. Although we could ask the datapath to give us this information on every ACK or loss detected, this wouldn't scale well. Since it takes one RTT for our algorithm to get feedback about a given packet on the network in steady state, it is pretty natural to update our state once per RTT (note: this is by no means fundamentally <em>correct</em>, so feel free to play around with differnet time scales!). A common pattern in CCP is to aggregate per-ACK statistics (such as the number of bytes ACKed) over a given time interval and then periodically report them to the userspace agent, which handles the logic of how to adjust the window or rate.</p>
<p>Although they work in tandem, it makes sense to think about the datapath program first, since the userspace agent reacts to events generated by the datapath. (For a detailed background on CCP datapath programs, <a href="TODO">read this</a>.)</p>
<p>As mentioned above, for this algorithm we want to collect two statistics in the datapath, number of packets ACKed and number of packets lost, so we'll define our <code>Report</code> structure as follows:</p>
<pre><code>(def (Report
    (volatile packets_acked 0)
    (volatile packets_lost 0)
))
</code></pre>
<p>The <code>0</code> after each value sets the default value and the <code>volatile</code> keyword tells the datapath to reset each value to it's default (0) after each <code>report</code> command.</p>
<p>Next, we'll specify our event handlers. First, we'll use the <code>when true</code> event to update our counters on each ACK (the event handler is run on each ACK, represented by the <code>Ack</code> structure):</p>
<pre><code>(when true
    (:= Report.packets_acked (+ Report.packets_acked Ack.packets_acked))
    (:= Report.packets_lost (+ Report.packets_lost Ack.lost_pkts_sample))
    (fallthrough)
)
</code></pre>
<p>The <code>(fallthrough)</code> statement tells the datapath to continue checking the rest of our event handlers. Without this statement, the datapath would stop here even if the other event conditions resolved to true.</p>
<p>The only other condition we need is a timer that sends a report once per RTT. This can be implemented using the <code>Micros</code> variable. This variable starts at 0 and represents the number of microseconds since it was last reset. (<code>Flow</code> contains some flow-level statistics, such as the datapath's current estimate of the RTT in microseconds, which comes in handy here):</p>
<pre><code>(when (&gt; Micros Flow.rtt_sample_us)
    (report)
    (:= Micros 0)
)
</code></pre>
<p>This condition resolves to true if <code>Micros</code> is greater than one RTT, and then resets it so that it can fire again on the next RTT. (NOTE: Micros is only reset by you. If you forgot to reset it, this condition would keep firing on every ACK because it will only be increment on each ACK).</p>
<p>Although this is not absolutely necessary, when a loss happens, we should probably know about that right away. A loss (in the simplistic model assumed by this algorithm) indicates that we are putting packets into the network too quickly. Therefore, if we were to continue sending at this rate for up to 1 RTT after receiving the first loss, we may introduce further losses. We can add another <code>when</code> clause to give us a report immediately upon any loss.</p>
<pre><code>(when (&gt; Report.packets_lost 0)
    (report)
)
</code></pre>
<p>We can now write <code>init_programs</code> by putting this together into a string literal and giving our program a name (&quot;default&quot;):</p>
<pre><code class="language-python">def init_programs(self):
    return [
        ((&quot;default&quot;), (&quot;&quot;&quot;\
            (def (Report
                (volatile packets_acked 0)
                (volatile packets_lost 0)
            ))
            (when true
                (:= Report.packets_acked (+ Report.packets_acked Ack.packets_acked))
                (:= Report.packets_lost (+ Report.packets_lost Ack.lost_pkts_sample))
                (fallthrough)
            )
            (when (&gt; Micros Flow.rtt_sample_us)
                (report)
                (:= Micros 0)
            )
            (when (&gt; Report.packets_lost 0)
                (report)
            )
        &quot;&quot;&quot;)
    ]
</code></pre>
<p><strong>NOTE</strong>: If you don't return any programs here, there will be no logic to decide when your algorithm receives reports, and thus your algorithm won't receive any callbacks beyond the creation of each flow.</p>
<a class="header" href="#writing-create" id="writing-create"><h1>Writing <code>create</code></h1></a>
<a class="header" href="#on_createself" id="on_createself"><h1>on_create(self)</h1></a>
<p>As mentioned before, we'll do two simple things here:</p>
<ol>
<li>Initialize state.</li>
</ol>
<p>The only state our algorithm needs is a congestion window. We'll start by setting a congestion window equal to 10 full packets. We can get the size of a packet (the maximum segment size, or MSS) from the <code>datapath_info</code> struct that is automatically provided in <code>self</code>:</p>
<pre><code class="language-python">self.cwnd = float(self.datapath_info.mss * 10)
</code></pre>
<ol start="2">
<li>Set the initial datapath program.</li>
</ol>
<p>In this case, we only have one, but if you had created multiple programs in <code>init_programs</code> you could choose to use any of them here. The second argument allows us to initialize some values within the datapath. The <code>self.cwnd</code> variable we created above is our internal notion of the cwnd, but we need to explicitly send this value to the datapath as well.</p>
<pre><code class="language-python">self.set_program(&quot;default&quot;, [&quot;Cwnd&quot;, self.cwnd])
</code></pre>
<p><strong>NOTE</strong>: There is no default program. Even if you returned programs in <code>init_programs</code>, if you don't set one here, again your algorithm won't receive any more callbacks for this flow.</p>
<p><strong>NOTE</strong>: As mentioned above, the userspace agent is totally separate from the datapath. Any state kept here does not change anything in the datapath automatically. If you want to update variables, such as the cwnd or rate, in the datapath, you need to explicitly do so using <code>set_program</code> or <code>update_fields</code>.</p>
<a class="header" href="#on_reportself-r" id="on_reportself-r"><h1>on_report(self, r)</h1></a>
<p>Now we can implement the core algorithm logic. The structure of <code>r</code> was defined in the <code>Report</code> structure of our datapath program, so we can access our two fields here: <code>r.packets_acked</code> and <code>r.packets_lost</code>. First, we'll calculate the correct cwnd adjustment:</p>
<pre><code class="language-python">if r.packets_lost &gt; 0:
    self.cwnd /= 2
else:
    self.cwnd += (self.datapath_info.mss * r.packets_acked) * (1 / self.cwnd)
</code></pre>
<p>Then we send that value to the datapath:</p>
<pre><code>self.datapath.update_fields([&quot;Cwnd&quot;, self.cwnd])
</code></pre>
<a class="header" href="#full-aimd-source-code" id="full-aimd-source-code"><h1>Full AIMD Source Code</h1></a>
<pre><code class="language-python">import sys
import portus

class AIMDFlow():
    INIT_CWND = 10

    def __init__(self, datapath, datapath_info):
        self.datapath = datapath
        self.datapath_info = datapath_info
        self.init_cwnd = float(self.datapath_info.mss * AIMDFlow.INIT_CWND)
        self.cwnd = self.init_cwnd
        self.datapath.set_program(&quot;default&quot;, [(&quot;Cwnd&quot;, self.cwnd)])

    def on_report(self, r):
        if r.loss &gt; 0 or r.sacked &gt; 0:
            self.cwnd /= 2
        else:
            self.cwnd += (self.datapath_info.mss * (r.acked / self.cwnd))
        self.cwnd = max(self.cwnd, self.init_cwnd)
        self.datapath.update_field(&quot;Cwnd&quot;, int(self.cwnd))


class AIMD(portus.AlgBase):

    def datapath_programs(self):
        return {
                &quot;default&quot; : &quot;&quot;&quot;\
                (def (Report
                    (volatile acked 0) 
                    (volatile sacked 0) 
                    (volatile loss 0) 
                    (volatile timeout false)
                    (volatile rtt 0)
                    (volatile inflight 0)
                ))
                (when true
                    (:= Report.inflight Flow.packets_in_flight)
                    (:= Report.rtt Flow.rtt_sample_us)
                    (:= Report.acked (+ Report.acked Ack.bytes_acked))
                    (:= Report.sacked (+ Report.sacked Ack.packets_misordered))
                    (:= Report.loss Ack.lost_pkts_sample)
                    (:= Report.timeout Flow.was_timeout)
                    (fallthrough)
                )
                (when (|| Report.timeout (&gt; Report.loss 0))
                    (report)
                    (:= Micros 0)
                )
                (when (&gt; Micros Flow.rtt_sample_us)
                    (report)
                    (:= Micros 0)
                )
            &quot;&quot;&quot;
        }

    def new_flow(self, datapath, datapath_info):
        return AIMDFlow(datapath, datapath_info)

alg = AIMD()

portus.start(&quot;netlink&quot;, alg, debug=True)

</code></pre>
<a class="header" href="#running-ccp-algorithms" id="running-ccp-algorithms"><h1>Running CCP Algorithms</h1></a>
<p>At this point, you should have an algorithm that builds successfully, either by following
the instructions in <a href="./setup/index.html">Setup</a> to build an existing algorithm or by writing and
building your own.</p>
<p>First, you need to start the CCP user agent:</p>
<p><details><summary><b>Rust</b></summary><p></p>
<p>When you run <code>cargo build</code> in a CCP algorithm repository, <code>cargo</code> puts all of the build files
and final binaries in the local <code>./target</code> directory. You can use the following command
to start the CCP userspace agent:</p>
<pre><code>sudo ./target/[MODE]/[ALG_NAME] --ipc [IPC]
</code></pre>
<ul>
<li><code>MODE</code> is either debug or release. You should run <code>release</code> unless you're running into problems.</li>
<li>Check the top of <code>Cargo.toml</code> to find the exact algorithm name. It is usually what you'd expect.</li>
<li><code>IPC</code> specifies what IPC mechanism should be used to contact the datapath component.
It can either &quot;netlink&quot; (only for Kernel), &quot;chardev&quot; for character device, or &quot;unix&quot; for unix
sockets.
<ul>
<li><strong>IMPORTANT</strong> -- this must match the parameters you provided when setting up the
datapath component.</li>
<li><code>sudo</code> is only necessary if the IPC mechanism requires it. It is currently required for
netlink sockets and the character device since they communicate with the Linux kernel,
but not required if you are using unix sockets.</li>
</ul>
</li>
</ul>
<p>For example, a typical run of BBR with the Linux Kernel would look like this:</p>
<pre><code>sudo ./target/release/bbr --ipc netlink
</code></pre>
</p></details>
<br/>
<details><summary><b>Python</b></summary><p>
<p>If you haven't already, install <code>portus</code> via pip: <code>pip install --user portus</code>.</p>
<p>Simply run <code>sudo python [ALG].py</code>. If you need to change the ipc mechanism, see the
<code>connect</code> method in the python source file. We have not provided command line arguments
by default, but you can always add them for convenience by using e.g. <code>argparse</code>.</p>
</p></details>
<p><br/></p>
<hr/>
<br/>
<p>Now that CCP is running, any sockets that set the <code>TCP_CONGESTION</code> sockopt to <code>&quot;ccp&quot;</code> will
use this algorithm implementation. Some applications such as <code>iperf</code> conveniently allow
this to be set directly from the command line.
Add <code>-Z ccp</code> for <code>iperf</code>(v2) or <code>-C ccp</code> for <code>iperf3</code>.</p>
<p>This is a work in progress. Coming Soon!</p>
<hr />
<br />
<a class="header" href="#debugging-todo" id="debugging-todo"><h1>Debugging (TODO)</h1></a>
<p>Use <code>sys.stdout.write(&quot;...\n&quot;)</code></p>
<a class="header" href="#emulation-todo" id="emulation-todo"><h1>Emulation (TODO)</h1></a>
<p>Install Mahimahi</p>
<p><code>iperf -s -p 9001</code></p>
<p><code>iperf -c $MAHIMAHI-BASE -p 9001 -i 1 -Z ccp</code></p>
<a class="header" href="#live-monitoring-todo" id="live-monitoring-todo"><h1>Live Monitoring (TODO)</h1></a>
<p><a href="http://github.com/fcangialosi/mm-live">mm-live</a></p>
<a class="header" href="#common-problems" id="common-problems"><h1>Common Problems</h1></a>
<a class="header" href="#building-userspace-agent" id="building-userspace-agent"><h2>Building Userspace Agent</h2></a>
<ul>
<li>Make sure <code>rust</code> and <code>cargo</code> are up to date using <code>rustup update</code></li>
<li>Make sure you are using the nightly version of Rust when building with Cargo</li>
<li>If you have problems installing python with <code>pip</code>, try building the language
bindings from the Portus repository directly (just clone Portus and run <code>make</code> in the <code>python/</code> directory).</li>
</ul>
<a class="header" href="#building-datapath-component" id="building-datapath-component"><h2>Building Datapath Component</h2></a>
<p><strong>Linux Kernel</strong></p>
<ul>
<li>Make sure you are using a supported kernel version: <code>4.13 &lt;= version &lt;= 4.16</code></li>
<li>If you recently installed a new kernel, make sure you have rebooted your machine</li>
<li>If you are unable to install</li>
</ul>
<a class="header" href="#running-ccp" id="running-ccp"><h2>Running CCP</h2></a>
<ul>
<li>
<p>If you get an error like the following, it means portus is not able to communicate with
your datapath. This is either because (1) the datapath integration is not installed / running,
(2) you have selected a different IPC mechanism than the datapath, or (3) the IPC mechanism is not
working.</p>
<blockquote>
<p>'called <code>Result::unwrap()</code> on an <code>Err</code> value: Error(&quot;Failed to install datapath program &quot;copa&quot;: Error(&quot;portus err: No such file or directory (os error 2)&quot;)&quot;)', src/libcore/result.rs:1009:5</p>
</blockquote>
</li>
</ul>
<a class="header" href="#adding-datapath-support" id="adding-datapath-support"><h1>Adding Datapath Support</h1></a>
<p>In order to collect measurements about the network and actually affect the sending behavior of flows, the userspace agent must communicate with the transport layer (datapath). We have designed a common API for the communication between userspace agent and datapath and implemented this in a <code>C</code> library called <code>libccp</code>. The API is simple and makes supporting a new datapath relatively easy. This rest of this section describes how to use <code>libccp</code> to implement a new datapath.</p>
<p>All three of the datapath integrations we provide use <code>libccp</code>, so these may be useful references for writing your own datapath integration.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
